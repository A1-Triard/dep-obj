# dep-obj

Dependency object: effective reactive heterogeneous container.

## Define dependency type

The dependency objects system bases on [`component-arena`](https://crates.io/crates/components-arena).
A component may have multiply dependency objects as its parts. Some of them may be dynamicaly typed
and/or optional. Lets see an example of simple component with one dependency object of fixed type.

Consider as an example carryable game object `Item`.

To describe abstract entity `Item`, we will need the following list of types:
- a component data holder `ItemData`;
- an id of component `Item`;
- a dependency object type `ItemProps`.

First, define the component containing the dependency object:

```rust
macro_attr! {
    #[derive(Debug, Component!)]
    struct ItemData {
        props: ItemProps,
    }
}
```

Then, to maitain an encapsulation, wrap `Id<ItemData>` into a newtype:

```rust
macro_attr! {
    #[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, NewtypeComponentId!)]
    pub struct Item(Id<ItemData>);
}
```

Dependency objects support properties inheritance. The tree structure of objects is defined
by the `DepObjId` trait implementation. We do not need inheritance for `Item`, and we
can express it and get appropriate «empty» `DepObjId` implementation
by marking it with the `DetachedDepObjId` trait:

```rust
impl DetachedDepObjId for Item { }
```

Now we are ready to specify the dependency type itself:

```rust
dep_type! {
    #[derive(Debug)]
    pub struct ItemProps in Item {
        name: Cow<'static, str> = Cow::Borrowed(""),
        base_weight: f32 = 0.0,
        weight: f32 = 0.0,
        equipped: bool = false,
        cursed: bool = false,
    }
}
```

All components need be emplaced in an appropriate arena. Lets create it:

```rust
pub struct Objs {
    items: Arena<ItemData>,
}
```

Now we have all structures encoded and can write `Item` methods.
First, we need a way to construct a new `Item`:

```rust
pub fn new(state: &mut dyn State) -> Item {
    let objs: &mut Objs = state.get_mut();
    objs.items.insert(|id| (ItemData { props: ItemProps::new_priv() }, Item(id)))
}
```

The `ItemProps::new_priv` is a constructor, generated by the `dep_type!` macro.
The `State` came from [`dyn-context`](https://crates.io/crates/dyn-context).
This crate is another foundation the dependency object system based on.

To make `Objs` usage more convinient it is worth to mark it as `SelfState`,
i.e. a state containing the only one part, which is `Objs` itself:

```rust
impl SelfState for Objs { }
```

Next, we need a way to destroy unneded items:

```rust
pub fn drop_self(self, state: &mut dyn State) {
    self.drop_bindings_priv(state);
    let objs: &mut Objs = state.get_mut();
    objs.items.remove(self.0);
}
```

And now the last, but not least: a function to access the depndency object in
the `props` field:

```rust
dep_obj! {
    pub fn props(self as this, objs: Objs) -> (ItemProps) {
        if mut {
            &mut objs.items[this.0].props
        } else {
            &objs.items[this.0].props
        }
    }
}
```

The `dep_obj` macro also generates the `drop_bindigs_priv` method we used in the `drop_self` method earlier.

Lets take a look at our `mod objs` as a whole:

```rust
mod objs {
    use components_arena::{Arena, Component, NewtypeComponentId, Id};
    use dep_obj::{DetachedDepObjId, dep_obj, dep_type};
    use dyn_context::state::{SelfState, State, StateExt};
    use macro_attr_2018::macro_attr;
    use std::borrow::Cow;

    pub struct Objs {
        items: Arena<ItemData>,
    }

    impl SelfState for Objs { }

    macro_attr! {
        #[derive(Debug, Component!)]
        struct ItemData {
            props: ItemProps,
        }
    }

    macro_attr! {
        #[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, NewtypeComponentId!)]
        pub struct Item(Id<ItemData>);
    }

    impl DetachedDepObjId for Item { }

    dep_type! {
        #[derive(Debug)]
        pub struct ItemProps in Item {
            name: Cow<'static, str> = Cow::Borrowed(""),
            base_weight: f32 = 0.0,
            weight: f32 = 0.0,
            equipped: bool = false,
            cursed: bool = false,
        }
    }

    impl Item {
        pub fn new(state: &mut dyn State) -> Item {
            let objs: &mut Objs = state.get_mut();
            objs.items.insert(|id| (ItemData { props: ItemProps::new_priv() }, Item(id)))
        }

        pub fn drop_self(self, state: &mut dyn State) {
            self.drop_bindings_priv(state);
            let objs: &mut Objs = state.get_mut();
            objs.items.remove(self.0);
        }

        dep_obj! {
            pub fn props(self as this, objs: Objs) -> (ItemProps) {
                if mut {
                    &mut objs.items[this.0].props
                } else {
                    &objs.items[this.0].props
                }
            }
        }
    }
}
```

The things we lack here are `Objs` constructor, and, unfortunatly, destructor.
Adding constructor is straightforward. The destructor however is tricky.
The `Item::drop_self` method do two things:
first, it drops all bindings item owes, and second, it removes items from arena.
The second thing would do automatically, but bindings require manual destroying.
Thus we need explicit `Objs` destructor to correctly drop all `Item`s' bindings.

But we cannot just implement `Drop` for `Objs` because we need `State` parameter
to call `Item::drop_bindings_priv`. Unfortunatly, Rust does not support a
linear types concept, which would allow to have parameters in `drop` method.
But `dyn-context` crate contains some helpful things, allowing to express
such type properties as good as it is possible in Rust for now.

First, we need to introduce new intermediate private structure `Objs_`, and
move `items` from `Objs` to `Objs_`. The `Objs` itself is becoming now
a wrap around `Objs_`:

```rust
pub struct Objs(StateDrop<Objs_>);
```

To make this code compiles, we need to implement `RequresStateSrop` for `Objs_`:

```rust
impl RequiresStateDrop for Objs_ {
    fn get(state: &dyn State) -> &StateDrop<Self> {
        &state.get::<Objs>().0
    }

    fn get_mut(state: &mut dyn State) -> &mut StateDrop<Self> {
        &mut state.get_mut::<Objs>().0
    }

    fn before_drop(state: &mut dyn State) {
        let objs: &Objs = state.get();
        let items = objs.0.items.items().ids().collect::<Vec<_>>();
        for item in items {
            item.drop_bindings_priv(state);
        }
    }

    fn drop_incorrectly(self) {
        debug_panic!("Objs should be dropped with the drop_self method");
    }
}
```

And now we can write public constructor and destructor for `Objs`:

```rust
impl Objs {
    pub fn new() -> Objs {
        Objs(StateDrop::new(Objs_ { items: Arena::new() }))
    }

    pub fn drop_self(state: &mut dyn State) {
        Objs_::drop_self(state);
    }
}
```

The final version of `mod objs`:

```rust
mod objs {
    use components_arena::{Arena, Component, NewtypeComponentId, Id};
    use debug_panic::debug_panic;
    use dep_obj::{DetachedDepObjId, dep_obj, dep_type};
    use dyn_context::state::{RequiresStateDrop, SelfState, State, StateDrop, StateExt};
    use macro_attr_2018::macro_attr;
    use std::borrow::Cow;

    pub struct Objs(StateDrop<Objs_>);

    impl SelfState for Objs { }

    struct Objs_ {
        items: Arena<ItemData>,
    }

    impl RequiresStateDrop for Objs_ {
        fn get(state: &dyn State) -> &StateDrop<Self> {
            &state.get::<Objs>().0
        }

        fn get_mut(state: &mut dyn State) -> &mut StateDrop<Self> {
            &mut state.get_mut::<Objs>().0
        }

        fn before_drop(state: &mut dyn State) {
            let items = Self::get(state).get().items.items().ids().map(Item).collect::<Vec<_>>();
            for item in items {
                item.drop_bindings_priv(state);
            }
        }

        fn drop_incorrectly(self) {
            debug_panic!("Objs should be dropped with the drop_self method");
        }
    }

    impl Objs {
        pub fn new() -> Objs {
            Objs(StateDrop::new(Objs_ { items: Arena::new() }))
        }

        pub fn drop_self(state: &mut dyn State) {
            <StateDrop<Objs_>>::drop_self(state);
        }
    }

    macro_attr! {
        #[derive(Debug, Component!)]
        struct ItemData {
            props: ItemProps,
        }
    }

    macro_attr! {
        #[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, NewtypeComponentId!)]
        pub struct Item(Id<ItemData>);
    }

    impl DetachedDepObjId for Item { }

    dep_type! {
        #[derive(Debug)]
        pub struct ItemProps in Item {
            name: Cow<'static, str> = Cow::Borrowed(""),
            base_weight: f32 = 0.0,
            weight: f32 = 0.0,
            equipped: bool = false,
            cursed: bool = false,
        }
    }

    impl Item {
        pub fn new(state: &mut dyn State) -> Item {
            let objs: &mut Objs = state.get_mut();
            objs.0.get_mut().items.insert(|id| (ItemData { props: ItemProps::new_priv() }, Item(id)))
        }

        pub fn drop_self(self, state: &mut dyn State) {
            self.drop_bindings_priv(state);
            let objs: &mut Objs = state.get_mut();
            objs.0.get_mut().items.remove(self.0);
        }

        dep_obj! {
            pub fn props(self as this, objs: Objs) -> (ItemProps) {
                if mut {
                    &mut objs.0.get_mut().items[this.0].props
                } else {
                    &objs.0.get().items[this.0].props
                }
            }
        }
    }
}
```

For now out `Item` does not have any meaningful behavior. Lets create some.
There are thow different concepts where to place this code. In the first one,
code can be encapsulated inside `Item` (actually in `Item::new`). In the other one
behavior are separated from data description. Lets stick to the second
approach and keep the behavior outside of `mod objs`.

```rust
pub fn new_item(state: &mut dyn State) -> Item {
    let item = Item::new(state);
    let weight = Binding3::new(state, (), |(), base_weight, cursed, equipped| Some(
        if equipped && cursed { base_weight + 100.0 } else { base_weight }
    ));
    ItemProps::WEIGHT.bind(state, item.props(), weight);
    weight.set_source_1(state, &mut ItemProps::BASE_WEIGHT.value_source(item.props()));
    weight.set_source_2(state, &mut ItemProps::CURSED.value_source(item.props()));
    weight.set_source_3(state, &mut ItemProps::EQUIPPED.value_source(item.props()));
    return item;
}
```

With the code above we have created functional dependency between four `Item`
properties: `weigth` now is a function of other three properties, and will be
updated automatically when any of the them changes.

Finally, lets write some test code to make our just builded game system work:

```
fn run(state: &mut dyn State) {
    let item = new_item(state);

    let weight = Binding1::new(state, (), |(), weight| Some(weight));
    weight.set_target_fn(state, (), |_state, (), weight| {
        println!("Item weight changed, new weight: {}", weight);
    });
    weight.set_source_1(state, &mut ItemProps::WEIGHT.value_source(item.props()));

    println!("> item.base_weight = 5.0");
    ItemProps::BASE_WEIGHT.set(state, item.props(), 5.0).immediate();

    println!("> item.cursed = true");
    ItemProps::CURSED.set(state, item.props(), true).immediate();

    println!("> item.equipped = true");
    ItemProps::EQUIPPED.set(state, item.props(), true).immediate();

    println!("> item.cursed = false");
    ItemProps::CURSED.set(state, item.props(), false).immediate();

    weight.drop_self(state);
    item.drop_self(state);
}
```

And the really last thing to do: construct `State` instance and call `run`.
Our system requires `State` containing `Objs` and special arena for bindings.
It can be easily reached with `merge_mut_and_then` method, combining two
state objects into a single one. And, of course, we should not forget to
call `Objs::drop_self` at the end:

```rust
fn main() {
    (&mut Objs::new()).merge_mut_and_then(|state| {
        run(state);
        Objs::drop_self(state);
    }, &mut Bindings::new());
}
```
