# dep-obj

Dependency object: effective reactive heterogeneous container.

## Define dependency type

The dependency objects system bases on [`component-arena`](https://crates.io/crates/components-arena).
A component may have multiply dependency objects as its parts. Some of them may be dynamicaly typed
and/or optional. Lets see an example of simple component with one dependency object of fixed type.

Consider as an example carryable game object `Item`.

To describe abstract entity `Item`, we will need the following list of types:
- a component data holder `ItemData`;
- an id of component `Item`;
- a dependency object type `ItemProps`.

First, define the component containing the dependency object:

```rust
macro_attr! {
    #[derive(Debug, Component!)]
    struct ItemData {
        props: ItemProps,
    }
}
```

Then, to maitain an encapsulation, wrap `Id<ItemData>` into a newtype:

```rust
macro_attr! {
    #[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, NewtypeComponentId!)]
    pub struct Item(Id<ItemData>);
}
```

Dependency objects support properties inheritance. The tree structure of objects is defined
by the `DepObjId` trait implementation. We do not need inheritance for `Item`, and we
can express it and get appropriate «empty» `DepObjId` implementation
by marking it with the `DetachedDepObjId` trait:

```rust
impl DetachedDepObjId for Item { }
```

Now we are ready to specify the dependency type itself:

```rust
dep_type! {
    #[derive(Debug)]
    pub struct ItemProps in Item {
        name: Cow<'static, str> = Cow::Borrowed(""),
        base_weight: f16 = 0.0,
	weight: f16 = 0.0,
        equipped: bool = false,
        cursed: bool = false,
    }
}
```

All components need be emplaced in an appropriate arena. Lets create it:

```rust
pub struct Game {
    items: Arena<ItemData>,
    bindings: Bindings,
}
```

We also have put `Bindings` in the `Game` to store reactive chains
we are supposed to build to make game mechanics.

Now we have all structures encoded and can write `Item` methods.
First, we need a way to construct a new `Item`:

```rust
pub fn new(state: &mut dyn State) -> Item {
    let game: &mut Game = state.get_mut();
    game.items.insert(|id| (ItemData { props: ItemProps::new_priv() }, Item(id)))
}
```

The `ItemProps::new_priv` is a constructor, generated by the `dep_type!` macro.

Next, we need a way to destroy unneded items:

```rust
pub fn drop_item(self, state: &mut dyn State) {
    self.drop_bindings_priv(state);
    let game: &mut Game = state.get_mut();
    game.items.remove(self.0);
}
```

And now the last, but not least: a function to access the depndency object in
the `props` field:

```rust
dep_obj! {
    pub fn props(self as this, game: Game) -> (ItemProps) {
        if mut {
            &mut game.items[this.0].props
        } else {
            &game.items[this.0].props
        }
    }
}
```

The `dep_obj` macro also generates the `drop_bindigs_priv` method we used in the `drop_item` method earlier.

Lets take a look at our `mod game` as a whole:

```rust
mod game {
    use components_arena::{Arena, Component, NewtypeComponentId, Id};
    use dep_obj::{DetachedDepObjId, dep_type};
    use dep_obj::binding:Bindings;
    use macro_attr_2018::macro_attr;

    pub struct Game {
        items: Arena<ItemData>,
        bindings: Bindings,
    }

    macro_attr! {
        #[derive(Debug, Component!)]
        struct ItemData {
            props: ItemProps,
        }
    }

    macro_attr! {
        #[derive(Debug, Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, NewtypeComponentId!)]
        pub struct Item(Id<ItemData>);
    }

    impl DetachedDepObjId for Item { }

    dep_type! {
        #[derive(Debug)]
        pub struct ItemProps in Item {
            name: Cow<'static, str> = Cow::Borrowed(""),
            weight: f16 = 0.0,
            equipped: bool = false,
            cursed: bool = false,
        }
    }

    impl Item {
        pub fn new(state: &mut dyn State) -> Item {
            let game: &mut Game = state.get_mut();
            game.items.insert(|id| (ItemData { props: ItemProps::new_priv() }, Item(id)))
        }

        pub fn drop_item(self, state: &mut dyn State) {
            self.drop_bindings_priv(state);
            let game: &mut Game = state.get_mut();
            game.items.remove(self.0);
        }

        dep_obj! {
            pub fn props(self as this, game: Game) -> (ItemProps) {
                if mut {
                    &mut game.items[this.0].props
                } else {
                    &game.items[this.0].props
                }
            }
        }
    }
}
```
